{
    "version": "https://jsonfeed.org/version/1",
    "title": "Vegetable Blog • All posts by \"ndk\" tag",
    "description": "",
    "home_page_url": "http://ericcd.com",
    "items": [
        {
            "id": "http://ericcd.com/2022/02/28/Android-reverce-2022-28-1/",
            "url": "http://ericcd.com/2022/02/28/Android-reverce-2022-28-1/",
            "title": "Android 逆向 - 2022.28-1",
            "date_published": "2022-02-28T01:34:57.000Z",
            "content_html": "<p>记录一些 jni 中的函数使用与静态注册相关知识。<br />\n<span id=\"more\"></span></p>\n<h2 id=\"可执行程序编译\"><a class=\"anchor\" href=\"#可执行程序编译\">#</a> 可执行程序编译</h2>\n<p>首先准备 <span class=\"exturl\" data-url=\"aHR0cDovL0FuZHJvaWQubWs=\">Android.mk</span> 文件，文件内容如下所示：<br />\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ LOCAL_PATH := $(call my-dir)</span><br><span class=\"line\">$ include $(CLEAR_VARS)</span><br><span class=\"line\">$ LOCAL_ARM_MODE := arm #确定编译后的指令集 </span><br><span class=\"line\">$ LOCAL_MODULE := example #模块名称 </span><br><span class=\"line\">$ LOCAL_SRC_FILES := JNI_example.c #c 源文件 </span><br><span class=\"line\">$ LOCAL_LDLIBS += -llog #依赖库 </span><br><span class=\"line\">$ include $(BUILD EXECUTABLE) #将.c 构建为可执行程序，使用 shared_library 则会生成动态链接库， 使用 static_library 会生成静态链接库 </span><br></pre></td></tr></table></figure><br />\n 准备 <span class=\"exturl\" data-url=\"aHR0cDovL0FwcGxpY2F0aW9uLm1r\">Application.mk</span> 文件，文件内代码如下所示：<br />\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$  APP_API := x86 armeabi-v7a</span><br></pre></td></tr></table></figure><br />\n 在以上文件存储处打开 cmd，执行 ndk-build 指令生成 linux 下的可执行程序。</p>\n<h2 id=\"相关函数\"><a class=\"anchor\" href=\"#相关函数\">#</a> 相关函数</h2>\n<p>jni 中的函数可以在 /java/include 下的 jni.h 文件中查询，以下只列举了一些可能使用到的函数。</p>\n<h3 id=\"调用-java-层普通方法\"><a class=\"anchor\" href=\"#调用-java-层普通方法\">#</a> 调用 java 层普通方法</h3>\n<p><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ （*CallObjectMethod) (JNIEnv*, jobject, jmethodID, ...);</span><br></pre></td></tr></table></figure><br />\n 前两个为默认参数，第三个参数由以下方法获取。</p>\n<h3 id=\"获取-java-层实例方法的值\"><a class=\"anchor\" href=\"#获取-java-层实例方法的值\">#</a> 获取 java 层实例方法的值</h3>\n<p><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$  jmethodID (*GetMethodID) (JNIEnv*, jclass, const char*, const char*);</span><br></pre></td></tr></table></figure><br />\n 其中，第一个 const char * 为 java 层方法名称，第二个 const char * 为 java 层方法的签名 (即方法返回类型)，而 jclass 由以下方法获取：<br />\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ jclass (*FindClass) (JNIEnv*, const char*)</span><br></pre></td></tr></table></figure><br />\n 其中，const char * 为目标所在 class 的路径 (使用 \\ 代替.)。</p>\n<h3 id=\"获取-java-层实例字段的值\"><a class=\"anchor\" href=\"#获取-java-层实例字段的值\">#</a> 获取 java 层实例字段的值</h3>\n<p><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ jobject (*GetObjectField) (JNIEnv*, jobject , jfieldID);</span><br></pre></td></tr></table></figure><br />\n 其中，jfieldID 由以下代码获取：<br />\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ jfieldID (*GetFieldID) (JNIenv*, jclass, const char*, const char*);</span><br></pre></td></tr></table></figure><br />\n 第一个 const char * 为实例字段的名称，第二个 const char * 为实例字段签名 (即实例字段类型)。</p>\n<h3 id=\"设置-java-层实例字段的值\"><a class=\"anchor\" href=\"#设置-java-层实例字段的值\">#</a> 设置 java 层实例字段的值</h3>\n<p><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ void (*SetObjectField) (JNIEnv*, jobject, jfieldID, jobject);</span><br></pre></td></tr></table></figure><br />\n 第二个 jobject 为 java 层实例字段设置的值。</p>\n<h2 id=\"静态注册\"><a class=\"anchor\" href=\"#静态注册\">#</a> 静态注册</h2>\n<h3 id=\"生成-jni-头文件\"><a class=\"anchor\" href=\"#生成-jni-头文件\">#</a> 生成 jni 头文件</h3>\n<p>在 class 代码中声明 native 方法，之后在 cmd 窗口中切换到源码目录处，执行以下代码生成 jni 头文件：<br />\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ javah -jni com.example.main.class</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"编写-c-代码\"><a class=\"anchor\" href=\"#编写-c-代码\">#</a> 编写 c 代码</h3>\n<p>在 c 文件中 include 之前生成的头文件，之后便能在 c 文件中具体实现在头文件中声明的函数。</p>\n<h3 id=\"生成动态链接库\"><a class=\"anchor\" href=\"#生成动态链接库\">#</a> 生成动态链接库</h3>\n<p><span class=\"exturl\" data-url=\"aHR0cDovL3huLS01aHFtMWg4OXBzN295dzJiLm1r\">将之前的两个.mk</span> 文件同.c 与.h 文件放在同一文件夹下，使用 ndk-build 生成动态链接库文件。</p>\n<h3 id=\"调用动态链接库\"><a class=\"anchor\" href=\"#调用动态链接库\">#</a> 调用动态链接库</h3>\n<p>在 java 代码中使用以下代码调用生成的动态链接库：<br />\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ System.loadLibrary (&quot;Module&quot;)</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"总结\"><a class=\"anchor\" href=\"#总结\">#</a> 总结</h2>\n<p>将以上个部分内容相结合，即可实现在 native 层调用 java 函数或获取 java 变量值。</p>\n",
            "tags": [
                "jni",
                "ndk",
                "静态注册"
            ]
        }
    ]
}