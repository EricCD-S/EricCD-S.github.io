<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Vegetable Blog</title>
  
  
  <link href="http://ericcd.com/atom.xml" rel="self"/>
  
  <link href="http://ericcd.com/"/>
  <updated>2022-07-17T08:09:00.416Z</updated>
  <id>http://ericcd.com/</id>
  
  <author>
    <name>EricCD</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>web 安全相关网站资源记录</title>
    <link href="http://ericcd.com/2022/07/17/url-log/"/>
    <id>http://ericcd.com/2022/07/17/url-log/</id>
    <published>2022-07-17T07:14:42.000Z</published>
    <updated>2022-07-17T08:09:00.416Z</updated>
    
    <content type="html"><![CDATA[<p>记录一些学习到的 web 安全相关网站。<br /><span id="more"></span></p><h1 id="搜索引擎"><a class="anchor" href="#搜索引擎">#</a> 搜索引擎</h1><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuc2hvZGFuLmlvLw==">https://www.shodan.io/</span><br /><span class="exturl" data-url="aHR0cHM6Ly93d3cud2Vic2Nhbi5jYy8=">https://www.webscan.cc/</span> （同 ip 查询）<br /><span class="exturl" data-url="aHR0cHM6Ly9jcnQuc2gv">https://crt.sh/</span> （子域名查询）</p><h1 id="学习资源"><a class="anchor" href="#学习资源">#</a> 学习资源</h1><p><span class="exturl" data-url="aHR0cHM6Ly93ZWJzZWMucmVhZHRoZWRvY3MuaW8vemgvbGF0ZXN0L2luZGV4Lmh0bWw=">https://websec.readthedocs.io/zh/latest/index.html</span></p><h1 id="扫描工具"><a class="anchor" href="#扫描工具">#</a> 扫描工具</h1><p><span class="exturl" data-url="aHR0cHM6Ly9ubWFwLm9yZy8=">https://nmap.org/</span><br /><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2hlbGxvZ29sZHNuYWtlbWFuL21hc25tYXBzY2FuLVYxLjA=">https://github.com/hellogoldsnakeman/masnmapscan-V1.0</span>  （端口扫描器）<br /><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0VuYWJsZVNlY3VyaXR5L3dhZncwMGY=">https://github.com/EnableSecurity/wafw00f</span>  （WAF 扫描工具）<br /><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2JpdDR3b28vdGVlbW8=">https://github.com/bit4woo/teemo</span> （域名枚举工具）</p><h1 id="相关资源"><a class="anchor" href="#相关资源">#</a> 相关资源</h1><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0x1Y2lmZXIxOTkzL2Ntc3ByaW50">https://github.com/Lucifer1993/cmsprint</span>  （CMS 指纹库）<br /><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL000dGlyL0dpdGh1Yi1Nb25pdG9y">https://github.com/M4tir/Github-Monitor</span> （漏洞发布监控工具）<br /><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vYm1qb2tlci9wLzkzMjYyNTguaHRtbA==">https://www.cnblogs.com/bmjoker/p/9326258.html</span> （sqlmap 思维导图）</p><h1 id="sql-注入"><a class="anchor" href="#sql-注入">#</a> SQL 注入</h1><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3lvdW5neWFuZ3lhbmcwNC9Ob1NRTEF0dGFjaw==">https://github.com/youngyangyang04/NoSQLAttack</span><br /><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3NxbG1hcHByb2plY3Qvc3FsbWFw">https://github.com/sqlmapproject/sqlmap</span><br /><span class="exturl" data-url="aHR0cDovL2NleWUuaW8v">http://ceye.io/</span><br /><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0FET09PL0Ruc2xvZ1NxbGluag==">https://github.com/ADOOO/DnslogSqlinj</span></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;记录一些学习到的 web 安全相关网站。&lt;br /&gt;</summary>
    
    
    
    <category term="web" scheme="http://ericcd.com/categories/web/"/>
    
    
    <category term="web" scheme="http://ericcd.com/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>Android 框架 - init.rc 文件</title>
    <link href="http://ericcd.com/2022/03/31/Android-Framework-init-rc/"/>
    <id>http://ericcd.com/2022/03/31/Android-Framework-init-rc/</id>
    <published>2022-03-31T03:26:29.000Z</published>
    <updated>2022-03-31T03:32:34.449Z</updated>
    
    <content type="html"><![CDATA[<p>Android 框架中 init.rc 文件的相关知识。<br /><span id="more"></span><br />init.rc 文件不同于 init 进程，init 进程仅当编译完 Android 后才会生成，而 init.rc 文件存在于源码中。init 文件大致分为两部分，一部分是以 on 关键字开头的动作列表，一部分是以 service 关键字开头的服务列表。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Android 框架中 init.rc 文件的相关知识。&lt;br /&gt;</summary>
    
    
    
    <category term="Android" scheme="http://ericcd.com/categories/Android/"/>
    
    
    <category term="Knowledge" scheme="http://ericcd.com/tags/Knowledge/"/>
    
  </entry>
  
  <entry>
    <title>Android 框架 - init 进程</title>
    <link href="http://ericcd.com/2022/03/23/AndroidFramework-init/"/>
    <id>http://ericcd.com/2022/03/23/AndroidFramework-init/</id>
    <published>2022-03-23T03:25:48.000Z</published>
    <updated>2022-07-17T08:11:03.666Z</updated>
    
    <content type="html"><![CDATA[<p>Android 框架中 init 进程的相关知识。<br /><span id="more"></span><br />init 进程是 Android 启动后，由内核启动的第一个用户级进程。<br /><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 内核启动过程：</span><br><span class="line">#    start_kernel ()</span><br><span class="line">#    init_post ()</span><br><span class="line">#    run_init_process ()</span><br><span class="line">#</span><br><span class="line">#     static in noinline init_post (void)</span><br><span class="line">#     &#123;</span><br><span class="line">#               if (execute_command)&#123;</span><br><span class="line">#                          run_init_process (execute_command);</span><br><span class="line">#               &#125;</span><br><span class="line">#               run_init_process (&quot;/sbin/init&quot;);</span><br><span class="line">#               run_init_process (&quot;/etc/init&quot;);</span><br><span class="line">#               run_init_process (&quot;/bin/init&quot;);</span><br><span class="line">#               run_init_process (&quot;/bin/sh&quot;);</span><br><span class="line">#     &#125;</span><br></pre></td></tr></table></figure><br />init_post () 函数调用 run_init_process () 函数，获取注册在 execute_command 中的进程文件路径，执行 execve () 系统调用，execve () 函数执行参数传递过来的文件路径下的进程 。<br />当跟文件系统顶层目录中不存在 init 进程或未指定启动选项 &quot;init=&quot; 时，内核会到 /sbin,/etc,/bin 目录下查找 init 文件，如果仍未找到，则 init 进程停止，引发 Kernel Panic。</p><h1 id="init-工作流程"><a class="anchor" href="#init-工作流程">#</a> init 工作流程</h1><h2 id="sigchld-注册信号处理器"><a class="anchor" href="#sigchld-注册信号处理器">#</a> SIGCHLD 注册信号处理器</h2><p>当子进程终止时，会产生 SIGCHLD 信号，init 进程调用信号安装函数 sigaction ()，并通过参数传递至 sigaction 结构体中，完成信号处理器安装。<br />init 进程通过相关代码注册与子进程相关的 SIGCHLD 信号处理器，并把 sigaction 结构体中的 sa_flags 设置为 SA_NOCLDSTOP，该值表示仅当进程终止时才接受 SIGCHLD 信号。sigchld_handler 函数用于通知全局变量 signal_fd，SIGCHLD 信号已经发生。</p><h2 id="main-目录生成与挂载"><a class="anchor" href="#main-目录生成与挂载">#</a> main () 目录生成与挂载</h2><p>init 在注册完信号处理器后，创建并挂在启动所需目录。</p><h2 id="初始化-log-输出设备"><a class="anchor" href="#初始化-log-输出设备">#</a> 初始化 log 输出设备</h2><p>通过调用 log_init () 函数初始化 log 输出设备。</p><h2 id="解析-initrc-文件"><a class="anchor" href="#解析-initrc-文件">#</a> 解析 init.rc 文件</h2><p>init.rc 文件是 init 启动后执行的启动脚本，文件中记录着 init 进程执行的功能。在 Linux 系统中，它被定义在根文件系统的 /etc/rc.d/ 目录下，是启动时的可执行文件。<br />init.rc 文件在 Android 系统运行过程中用于通用的环境设置以及进程相关的定义，init.{hardware}.rc 用于定义 Android 在不同平台下的特定进程和环境设置等。<br />parse_config_file () 文件用于分析.rc 配置文件，参数为文件路径。读取 init.rc 文件后，生成动作列表与服务列表。根据 init.{hardware}.rc 生成的动作列表和服务列表会被添加到已生成的对应列表中去。</p><h2 id="执行-early-init-动作"><a class="anchor" href="#执行-early-init-动作">#</a> 执行 early-init 动作</h2><p>init 进程会依次执行 &quot;early-init , init ,early-boot , boot&quot; 片段中的命令。<br />通过 action_for_each_trigger () 将 early-init 中的命令保存到队列 action_add_queue_tail 中，之后通过 drain_action_queue () 函数将运行队列中的命令逐一取出执行。</p><h2 id="创建定义好的设备节点文件"><a class="anchor" href="#创建定义好的设备节点文件">#</a> 创建定义好的设备节点文件</h2><p>通过 device_init () 生成静态设备节点。</p><h2 id="初始化属性服务"><a class="anchor" href="#初始化属性服务">#</a> 初始化属性服务</h2><p>调用 property_init () 函数，在共享内存区域中，创建并初始化属性域。而后通过执行中的进程所提供的 API，访问属性域中的设置值。但更改属性值操作只能在 init 进程中运行，当修改属性值时，要预先向 init 进程提交值变更申请，然后 init 进程处理该申请，并修改属性值。</p><h2 id="显示启动-logo"><a class="anchor" href="#显示启动-logo">#</a> 显示启动 logo</h2><p>使用 load_565rle_image () 函数将文件显示在屏幕上，只需修改 INIT_IMAGE_FILE 即可更改启动 Logo。</p><h2 id="属性初始设置"><a class="anchor" href="#属性初始设置">#</a> 属性初始设置</h2><p>通过 property_set () 函数向属性域设置系统所需的一些初始值。这些设置的属性值由执行中的多种进程通过 property_get () API 来访问。</p><h2 id="执行-init-动作"><a class="anchor" href="#执行-init-动作">#</a> 执行 init 动作</h2><p>同 early-init。</p><h2 id="启动属性服务"><a class="anchor" href="#启动属性服务">#</a> 启动属性服务</h2><p>除了先前设置的属性外，start_property_service () 还会读取几个设置文件，并对属性进行初始化。在根文件系统的 /data/property 目录下，保存着进程生成或修改的属性值。向 init 提交修改申请后，init 进程生成 /dev/socket/property_service 来接受其它进程提交的申请。</p><h2 id="创建套接字"><a class="anchor" href="#创建套接字">#</a> 创建套接字</h2><p>用于 init 进程在收到子进程终止的信号时调用相应的 handler。</p><h2 id="执行与-action-list-的-early-bootbootproperty-相关的命令"><a class="anchor" href="#执行与-action-list-的-early-bootbootproperty-相关的命令">#</a> 执行与 Action List 的 early-boot,boot,property 相关的命令</h2><p>在 init.rc 文件的 boot 区段有一条 class_start 命令，用来逐一执行存在于服务列表中的进程列表。</p><h2 id="设置事件处理循环的监视事件"><a class="anchor" href="#设置事件处理循环的监视事件">#</a> 设置事件处理循环的监视事件</h2><p>注册在 POLL 中的文件描述符会在 poll () 函数中等待事件发生，若事件发生，则从 poll 函数中跳出并处理事件。<br />在确认事件发生前，先要在 action list 的命令中确认是否有尚未执行的命令，并执行这些命令。起初，在事件处理循环中，action list 与 service list 未含有需要执行的事情，但是在处理过注册的事件后，init 进程要做的事情会重新注册到 action list 与 service list 中。<br />当事件发生时，事件信息会保存在 pollfd 结构体的 udfs.revents 变量中，当 poll () 函数返回后，可以在 udfs 数组中的 revents 中查看哪些事件已经发生。<br />当子进程终止时，会产生 SIGCHLD 信号，POLLIN 事件会被注册到 udfs [2],revents 中。<br />在 Android 系统运行过程中，插入热的拔插设备时，将生成设备节点文件。<br />这部分函数还会处理属性变更请求。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Android 框架中 init 进程的相关知识。&lt;br /&gt;</summary>
    
    
    
    <category term="Android" scheme="http://ericcd.com/categories/Android/"/>
    
    
    <category term="Knowledge" scheme="http://ericcd.com/tags/Knowledge/"/>
    
  </entry>
  
  <entry>
    <title>Android 框架概述</title>
    <link href="http://ericcd.com/2022/03/23/Android-framework/"/>
    <id>http://ericcd.com/2022/03/23/Android-framework/</id>
    <published>2022-03-23T02:57:28.000Z</published>
    <updated>2022-07-17T08:10:28.166Z</updated>
    
    <content type="html"><![CDATA[<p>Android 框架相关知识概述。<br /><span id="more"></span></p><h1 id="android-启动过程"><a class="anchor" href="#android-启动过程">#</a> Android 启动过程</h1><p>Android 启动时，首先通过 bootloader (系统加载器) 加载 Linux 内核。Linux 加载启动时，先初始化内核，再调用 init 进程。</p><h1 id="init-进程"><a class="anchor" href="#init-进程">#</a> init 进程</h1><p>init 进程会运行 Android Framework 所需的 Daemon, Context Manager, Media Server, Zygote 等。</p><h2 id="daemon"><a class="anchor" href="#daemon">#</a> Daemon</h2><p>以下是 init 进程执行的 Daemon 进程。<br /><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#          USB Daemon (usbd): 管理 USB 连接。</span><br><span class="line">#          Android Debug Bridge Daemon (adbd): Android Debug Brige 连接管理。</span><br><span class="line">#          Debugger Daemon (debuggerd): 启动 Debugger 系统。</span><br><span class="line">#          Radio Interface Layer Daemon (rild): 管理无线通信连接。</span><br></pre></td></tr></table></figure></p><h2 id="context-manager"><a class="anchor" href="#context-manager">#</a> Context Manager</h2><p>Context Manager 是一个管理 Android 系统服务的重要进程，系统服务提供从相机，音频，视频处理到各种应用程序制作所需要的 API。<br />Context Manager 还提供用于 Android 内的各种系统服务信息。应用程序或 Frameword 内部模块在调用系统服务时，需要先向服务管理器申请，再通过 Binder IPC 调用系统服务。<br />系统启动时，Android 所有系统服务都要把各自的 handle 注册到 Context Manager。</p><h2 id="media-server"><a class="anchor" href="#media-server">#</a> Media Server</h2><p>Media Server 用于运行基于 C/C++ 的本地系统服务，如 Audio Flinger,Camera 等。</p><h2 id="zygote"><a class="anchor" href="#zygote">#</a> Zygote</h2><p>Zygote 进程用于缩短 Android 应用程序加载时间，每当执行 java 应用程序时，Zygote 会派生一个子进程来执行程序，该子进程就是虚拟机。</p><h2 id="system-server"><a class="anchor" href="#system-server">#</a> System Server</h2><p>Syetem Server 是 Android 系统的一个核心进程，它有 Zygote 创建，所以启动过程位于 Zygote 之后。在 System Server 中可以看到它建立的 Android 中的大部分服务，为了将运行在 System Server 中的 java 系统服务提供给 Android 程序或 Framework 内部模块调用，需要先将它们注册到 Context Manager 中。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Android 框架相关知识概述。&lt;br /&gt;</summary>
    
    
    
    <category term="Android" scheme="http://ericcd.com/categories/Android/"/>
    
    
    <category term="Knowledge" scheme="http://ericcd.com/tags/Knowledge/"/>
    
  </entry>
  
  <entry>
    <title>dex 文件结构</title>
    <link href="http://ericcd.com/2022/03/18/dex-structure/"/>
    <id>http://ericcd.com/2022/03/18/dex-structure/</id>
    <published>2022-03-18T02:42:11.000Z</published>
    <updated>2022-07-17T08:14:34.704Z</updated>
    
    <content type="html"><![CDATA[<p>dex 文件结构学习。<br /><span id="more"></span></p><h1 id="dex-整体结构"><a class="anchor" href="#dex-整体结构">#</a> dex 整体结构</h1><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#       struct dex&#123;</span><br><span class="line">#        Header;</span><br><span class="line">#        string_ids;</span><br><span class="line">#        type_ids;</span><br><span class="line">#        proto_ids;</span><br><span class="line">#        field_ids;</span><br><span class="line">#        methods_ids;</span><br><span class="line">#        class_defs;</span><br><span class="line">#        data;</span><br><span class="line">#        link_data;&#125;</span><br></pre></td></tr></table></figure></p><h1 id="header"><a class="anchor" href="#header">#</a> Header</h1><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#      struct  DexHeader&#123;</span><br><span class="line">#              magic [8];</span><br><span class="line">#              checksum;</span><br><span class="line">#              signature [kSHA1DigestLen];</span><br><span class="line">#              fileSize;</span><br><span class="line">#              headerSize;</span><br><span class="line">#              endianTag;</span><br><span class="line">#              linkSize;</span><br><span class="line">#              linkOff;</span><br><span class="line">#              mapOff;</span><br><span class="line">#              stringIdsSize;</span><br><span class="line">#              stringIdsOff;</span><br><span class="line">#              typeIdsSize;</span><br><span class="line">#              typeIdsOff;</span><br><span class="line">#              protoIdsSize;</span><br><span class="line">#              protoIdsOff;</span><br><span class="line">#              fieldIdsSize;</span><br><span class="line">#              fieldIdsOff;</span><br><span class="line">#              methodIdsSize;</span><br><span class="line">#              methodIdsOff;</span><br><span class="line">#              classDefsSize;</span><br><span class="line">#              classDefsOff;</span><br><span class="line">#              dataSize;</span><br><span class="line">#              dataOff;&#125;</span><br></pre></td></tr></table></figure><br />1.checksum：dex 文件校验和。<br />2. signature [kSHA1DigestLen]：整个 dex 文件通过 SHA-1 签名得到的值，占用 20 字节，用于检验 dex 文件。<br />3.endianTag: 字节序标记，用于指定 dex 运行环境的 cpu。<br />4.linkSzie 和 linkOff：指定链接段大小和文件偏移，通常情况下都为 0.linkSize 为 0 的话表示静态链接。<br />5.mapOff：指定 DexMapList 的文件偏移。<br />6.stringIdsSize 和 stringIdsOff：指定了 dex 文件中所有用到的字符串的个数和 string_ids 结构位置偏移。<br />7.typeIdsSize 和 TypeIdsOff：表示类的类型的数量和 type_ids 结构位置偏移。<br />8.protoIdsSize 和 protoIdsOff：表示 dex 文件中方法原型的个数和 proto_ids 结构位置偏移。<br />9.fieldIdsSize 和 fieldsIdsOff：表示 dex 文件中字段个数和 field_ids 结构位置偏移。<br />10.methodIdsSize 和 methodIdsOff：表示 dex 文件中的方法数量和 methods_ids 结构位置偏移。<br />11.classDefsSize 和 classDefsOff：指明 dex 文件中类的定义的相关信息。</p><h1 id="string_ids"><a class="anchor" href="#string_ids">#</a> string_ids</h1><p>string_ids 结构中，每 4 字节表示一个位置偏移，该偏移指向真正字符串的偏移地址，真正的字符串存在 data 中。</p><h1 id="type_ids"><a class="anchor" href="#type_ids">#</a> type_ids</h1><p>types_ids 中只存在一种数据 descriptorIdx，它的值为 string_ids 结构的索引。</p><h1 id="proto_ids"><a class="anchor" href="#proto_ids">#</a> proto_ids</h1><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#     struct proto_ids&#123;</span><br><span class="line">#              shortyIdx;   // 指向 string_Ids 列表的索引 </span><br><span class="line">#              returnTypeIdx;  // 指向 type_Id 列表的索引 </span><br><span class="line">#              parametersOff;  // 指向 type_list 的位置偏移 </span><br><span class="line">#              &#125;</span><br></pre></td></tr></table></figure></p><h2 id="type_list"><a class="anchor" href="#type_list">#</a> type_list</h2><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#     struct type_list&#123;</span><br><span class="line">#             size; //type_Item 的个数 </span><br><span class="line">#             type_item  list [1];  //type_Item 结构，只有一个 type_id 参数，指向 type_id 列表 </span><br><span class="line">#             &#125;</span><br></pre></td></tr></table></figure></p><h1 id="field_ids"><a class="anchor" href="#field_ids">#</a> field_ids</h1><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#        struct field_ids&#123;</span><br><span class="line">#             classIdx;  // 类的类型，指向 type_Id 列表的索引 </span><br><span class="line">#             typeIdx;  // 字段类型，指向 type_Id 列表的索引 </span><br><span class="line">#             nameIdx;  // 字段名，指向 string_Id 列表的索引 </span><br><span class="line">#             &#125;</span><br></pre></td></tr></table></figure></p><h1 id="methods_ids"><a class="anchor" href="#methods_ids">#</a> methods_ids</h1><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#      struct method_id&#123;</span><br><span class="line">#             classIdx;   // 类的类型，指向 type_Id 列表的索引 </span><br><span class="line">#             protoIdx;  // 声明类型，指向 proto_Id 列表的索引 </span><br><span class="line">#             nameIdx;  // 方法名，指向 string_Id 列表的索引 </span><br><span class="line">#             &#125;</span><br></pre></td></tr></table></figure></p><h1 id="class_defs"><a class="anchor" href="#class_defs">#</a> class_defs</h1><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#           struct    class_defs&#123;</span><br><span class="line">#                   classIdx;  // 类的类型，指向 type_Id 列表的索引 </span><br><span class="line">#                   accessFlags;  // 访问标志 </span><br><span class="line">#                   superclassIdx;  // 父类类型，指向 type_Id 列表的索引 </span><br><span class="line">#                   interfacesOff;  // 接口，指向 type_list 的偏移 </span><br><span class="line">#                   sourceFileIdx;  // 源文件名，指向 string_Ids 列表的索引 </span><br><span class="line">#                   annotationsOff;  // 注解，指向 annotationsDirectory_Item 结构 </span><br><span class="line">#                   classDataOff;  // 指向 class_data 结构的偏移 </span><br><span class="line">#                   staticValuesOff;  // 指向 encoded_array 结构的偏移 </span><br><span class="line">#                   &#125;</span><br></pre></td></tr></table></figure></p><h2 id="class_data"><a class="anchor" href="#class_data">#</a> class_data</h2><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#        struct DexClassData&#123;</span><br><span class="line">#              classDataHeaderheader;     // 指定字段与方法的个数 </span><br><span class="line">#              Field* staticFields;   // 静态字段，Field 结构 </span><br><span class="line">#              Field*instanceFields;  // 实例字段，Field 结构 </span><br><span class="line">#              Method*directMethods;  // 直接方法，Method 结构 </span><br><span class="line">#              Method*virtualMethods;  // 虚方法，Method 结构 </span><br><span class="line">#              &#125;</span><br></pre></td></tr></table></figure></p><h2 id="classdataheader"><a class="anchor" href="#classdataheader">#</a> classDataHeader</h2><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#   struct classDataHeader&#123;</span><br><span class="line">#               staticFieldsSize;  // 静态字段个数 </span><br><span class="line">#               instanceFieldsSize;  // 实例字段个数 </span><br><span class="line">#               directMethodsSize;  // 直接方法个数 </span><br><span class="line">#               virtualMethodsSize;  // 虚方法个数 </span><br><span class="line">#               &#125;</span><br></pre></td></tr></table></figure></p><h2 id="field"><a class="anchor" href="#field">#</a> Field</h2><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#       struct DexField&#123;</span><br><span class="line">#            field_Idx;  // 指向 field_Ids 的索引 </span><br><span class="line">#            accessFlags;  // 访问标志 </span><br><span class="line">#            &#125;</span><br></pre></td></tr></table></figure></p><h2 id="method"><a class="anchor" href="#method">#</a> Method</h2><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#           struct DexMethod&#123;</span><br><span class="line">#                   method_Idx;  // 指向 method_Ids 的索引 </span><br><span class="line">#                   accessFlags;  // 访问标志 </span><br><span class="line">#                   codeOff;  // 指向 code 结构的偏移 </span><br><span class="line">#                   &#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;dex 文件结构学习。&lt;br /&gt;</summary>
    
    
    
    <category term="Android" scheme="http://ericcd.com/categories/Android/"/>
    
    
    <category term="Knowledge" scheme="http://ericcd.com/tags/Knowledge/"/>
    
  </entry>
  
  <entry>
    <title>Android 逆向 - 2022.3.4-1</title>
    <link href="http://ericcd.com/2022/03/04/Android-reverce-2022.3.4-1/"/>
    <id>http://ericcd.com/2022/03/04/Android-reverce-2022.3.4-1/</id>
    <published>2022-03-04T01:34:29.000Z</published>
    <updated>2022-03-17T11:45:13.363Z</updated>
    
    <content type="html"><![CDATA[<p>记录一些常见的反调试策略。<br /><span id="more"></span><br />1.java 代码混淆。<br />2. 资源文件混淆：可以使用 MT 管理器来单独修改 apk 中的 dex 文件。<br />3. 签名验证。<br />4. 模拟器检测。<br />5. 关键文件检测。<br />6. 调试端口检测。<br />7. 进程名称检测。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;记录一些常见的反调试策略。&lt;br /&gt;</summary>
    
    
    
    <category term="Android逆向知识" scheme="http://ericcd.com/categories/Android%E9%80%86%E5%90%91%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="Android逆向" scheme="http://ericcd.com/tags/Android%E9%80%86%E5%90%91/"/>
    
  </entry>
  
  <entry>
    <title>Androidmanifest 修改实践</title>
    <link href="http://ericcd.com/2022/03/01/Androidmanifest-modify-2022.3.1-1/"/>
    <id>http://ericcd.com/2022/03/01/Androidmanifest-modify-2022.3.1-1/</id>
    <published>2022-03-01T13:09:53.000Z</published>
    <updated>2022-07-17T08:12:41.330Z</updated>
    
    <content type="html"><![CDATA[<p>在网上看见通过修改 Androidmanifest 来识别 apk 是否被重打包的方法，进行一次实践进行验证。<br /><span id="more"></span></p><h1 id="工具准备"><a class="anchor" href="#工具准备">#</a> 工具准备</h1><p>本次实践使用 Android Studio 编写实验代码，通过 010Editor 对 Androidmanifest 文件进行修改，使用 jarsign 对修改后的 apk 进行签名。另外，还会使用到 apktool 来对修改后的 apk 进行重打包，进而判断 apktool 是否会对 apk 造成影响。本次实践还使用到了 ddms 来查看日志输出，判断关键代码是否被触发。</p><h1 id="实践过程"><a class="anchor" href="#实践过程">#</a> 实践过程</h1><p>通过 Android Studio 编写 apk，为了实施方便，代码中仅包含.MainActivity 与.appApplication。其中，.appApplication 作为 application 中的 andtoid:name 标签值，其功能为输出一段日志信息。<br />进行第一次测试，ddms 能够准确捕获到该日志信息，确定函数顺利执行。<br />使用 Bandizip 提取 apk 中的 Androidmanifest.xml 文件（尝试过使用 winrar，但是该工具会破坏 apk 结构，造成无法进一步实验），使用 010Editor 对 Androidmanifest 进行修改，主要是对 stringChunk 与 resourceChunk 修改，将两段中存储的变量个数对齐，并将 string 值设置为 name，resourceID 设置为 0 (因为在 Android 标签的结构体中，使用同一索引值来寻找字符串与资源 ID。并且，不要动本来就有的 name 标签与 ID，后面的其它资源可能会用到，改了会报错)。此外，还要对 filesize 等部分进行相应的修改，此处不一一讨论。<br />将修改后的 Androidmanifest 放回 apk 中，删去 META-INF 文件，使用之前的签名文件 (keys.jks) 来对 apk 重新签名，签名使用到了 jarsign 工具，命令如下所示：<br /><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ jarsigner -keystore keys.jks -signedjar appsigned.apk appunsigned.apk key0 </span><br></pre></td></tr></table></figure></p><p>之后将重新签名完成的 apk 放入模拟器运行，ddms 没有接收到任何日志信息，可以发现.appApplication 未被执行。<br />使用 apktool 对 apk 进行重打包，再将生成的 apk 放入模拟器运行，ddms 再次接收到日志信息。</p><h1 id="结论"><a class="anchor" href="#结论">#</a> 结论</h1><p>Android 在运行时使用 ID 来寻找资源，当资源 ID 违法时 (本次实践中值为 0)，Android 会忽略该 ID 对应的资源 (本次实践中的.appApplication)。但是一旦使用 apktool 对 apk 进行重打包，apktool 会对 Androidmanifest 进行修复，将非法 ID 改为正常 ID，使得.appApplication 能够重新运行。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在网上看见通过修改 Androidmanifest 来识别 apk 是否被重打包的方法，进行一次实践进行验证。&lt;br /&gt;</summary>
    
    
    
    <category term="Android逆向实践" scheme="http://ericcd.com/categories/Android%E9%80%86%E5%90%91%E5%AE%9E%E8%B7%B5/"/>
    
    
    <category term="ddms" scheme="http://ericcd.com/tags/ddms/"/>
    
    <category term="Android逆向" scheme="http://ericcd.com/tags/Android%E9%80%86%E5%90%91/"/>
    
    <category term="Android Studio" scheme="http://ericcd.com/tags/Android-Studio/"/>
    
    <category term="apktool" scheme="http://ericcd.com/tags/apktool/"/>
    
    <category term="jarsign" scheme="http://ericcd.com/tags/jarsign/"/>
    
    <category term="010Editor" scheme="http://ericcd.com/tags/010Editor/"/>
    
  </entry>
  
  <entry>
    <title>日常遇到的 BUG 及其修复方式</title>
    <link href="http://ericcd.com/2022/02/28/bugs/"/>
    <id>http://ericcd.com/2022/02/28/bugs/</id>
    <published>2022-02-28T15:15:24.000Z</published>
    <updated>2022-07-17T08:14:20.366Z</updated>
    
    <content type="html"><![CDATA[<p>记录遇到过的 bug。<br /><span id="more"></span></p><h1 id="打开-monitorbat-时报错an-error-occured"><a class="anchor" href="#打开-monitorbat-时报错an-error-occured">#</a> 打开 monitor.bat 时报错：An error occured。</h1><p>jdk 版本太高了，改成了 1.8 版本顺利运行。</p><h1 id="夜神模拟器无法自动连接-android-studio"><a class="anchor" href="#夜神模拟器无法自动连接-android-studio">#</a> 夜神模拟器无法自动连接 Android Studio。</h1><p>切换到夜神模拟器安装目录下的 bin 文件夹，执行以下指令：<br /><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ adb connect 127.0.0.1:62001</span><br></pre></td></tr></table></figure></p><h1 id="使用-android-killer-重打包失败"><a class="anchor" href="#使用-android-killer-重打包失败">#</a> 使用 Android Killer 重打包失败</h1><p>更换成最新的 apktool。</p><h1 id="找不到-ddms"><a class="anchor" href="#找不到-ddms">#</a> 找不到 ddms</h1><p>ddms 已经更名成 monitor，并且使用前最好将 java 版本降为 javaSE1.8，否则可能报错。</p><h1 id="使用-ddms-查看不了夜神模拟器的日志输出"><a class="anchor" href="#使用-ddms-查看不了夜神模拟器的日志输出">#</a> 使用 ddms 查看不了夜神模拟器的日志输出</h1><p>换成雷神模拟器。</p><h1 id="使用-android-studio-时代码补全功能消失"><a class="anchor" href="#使用-android-studio-时代码补全功能消失">#</a> 使用 Android Studio 时代码补全功能消失</h1><ol><li>关闭省电模式。</li><li>重新进行以便 Grald Sync</li></ol><h1 id="在-android-studio-中加载动态库时提示找不到动态库"><a class="anchor" href="#在-android-studio-中加载动态库时提示找不到动态库">#</a> 在 Android studio 中加载动态库时提示找不到动态库</h1><p>在 build.gralde 中的 android {} 里添加以下代码。<br /><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$      sourceSets &#123;</span><br><span class="line">$                             main&#123;</span><br><span class="line">$                                         jniLibs.srcDirs=[&#x27;src/main/libs&#x27;]</span><br><span class="line">$                                      &#125;</span><br><span class="line">$                           &#125;</span><br></pre></td></tr></table></figure></p><h1 id="提示在动态库中找不到函数"><a class="anchor" href="#提示在动态库中找不到函数">#</a> 提示在动态库中找不到函数</h1><p>确定动态库已经加载，<span class="exturl" data-url="aHR0cDovL3huLS1qdnZ4cy5zbw==">检查.so</span> 文件，发现其中没有我自己编写的代码。查看 ndk-build 的 log，<span class="exturl" data-url="aHR0cDovL3huLS1waHFzM2xrNGpxMmRodmE1MDJiczdiZDRvOXdmYjRkZTY5ZG53eWIuc28=">发现虽然没报错且正常生成.so</span> 文件，但是没有编译.c 文件的步骤。检查 <span class="exturl" data-url="aHR0cDovL0FuZHJvaWQubWs=">Android.mk</span> 文件，发现 LOCAL_SRC_FILES 标签少写了最后的 S，导致 ndk-build 没有编译指定文件。</p><h1 id="使用-ndk-build-编译时提示-jniexport-后面缺少符号"><a class="anchor" href="#使用-ndk-build-编译时提示-jniexport-后面缺少符号">#</a> 使用 ndk-build 编译时提示 JNIEXPORT 后面缺少；符号</h1><p>自动生成的.h 文件中，函数定义末尾少了；符号，加上就不报错了。</p><h1 id="使用-frida-dexdump-脱壳时报错script-has-been-destroyed"><a class="anchor" href="#使用-frida-dexdump-脱壳时报错script-has-been-destroyed">#</a> 使用 Frida-dexdump 脱壳时报错：script has been destroyed</h1><p>可能是框架问题，但在本次实践中是由于 app 不稳定崩溃导致的。</p><h1 id="使用-class-结构时发现该结构实际长度比其中的数据长度长"><a class="anchor" href="#使用-class-结构时发现该结构实际长度比其中的数据长度长">#</a> 使用 class 结构时，发现该结构实际长度比其中的数据长度长</h1><p>因为编译器按照 4 字节对 class 进行对齐，不足的补 0，可以在代码开头加上以下声明来取消对齐。<br /><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#  pragma pack (1)  // 按照 1 字节对齐，等于没对齐。</span><br></pre></td></tr></table></figure></p><h1 id="使用-malloc-分配空间后向其中写入-char但是发现-cout-时后续跟了许多脏字符"><a class="anchor" href="#使用-malloc-分配空间后向其中写入-char但是发现-cout-时后续跟了许多脏字符">#</a> 使用 malloc 分配空间后，向其中写入 char，但是发现 cout 时后续跟了许多脏字符</h1><p>如果 malloc 申请的空间长度等于需要写入的字符长度，那么 cout 时在字符末尾找不到终止符，会继续读，直到遇见终止符为止。建议使用 calloc 来分配空间，该函数能将分配的空间初始化为 0，并且申请的空间长度应该为字符长度 + 1。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;记录遇到过的 bug。&lt;br /&gt;</summary>
    
    
    
    <category term="BUG修复" scheme="http://ericcd.com/categories/BUG%E4%BF%AE%E5%A4%8D/"/>
    
    
    <category term="bugs" scheme="http://ericcd.com/tags/bugs/"/>
    
  </entry>
  
  <entry>
    <title>Android 逆向 - 2022.28-1</title>
    <link href="http://ericcd.com/2022/02/28/Android-reverce-2022-28-1/"/>
    <id>http://ericcd.com/2022/02/28/Android-reverce-2022-28-1/</id>
    <published>2022-02-28T01:34:57.000Z</published>
    <updated>2022-07-17T08:20:50.194Z</updated>
    
    <content type="html"><![CDATA[<p>记录一些 jni 中的函数使用与静态注册相关知识。<br /><span id="more"></span></p><h1 id="可执行程序编译"><a class="anchor" href="#可执行程序编译">#</a> 可执行程序编译</h1><p>首先准备 <span class="exturl" data-url="aHR0cDovL0FuZHJvaWQubWs=">Android.mk</span> 文件，文件内容如下所示：<br /><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ LOCAL_PATH := $(call my-dir)</span><br><span class="line">$ include $(CLEAR_VARS)</span><br><span class="line">$ LOCAL_ARM_MODE := arm #确定编译后的指令集 </span><br><span class="line">$ LOCAL_MODULE := example #模块名称 </span><br><span class="line">$ LOCAL_SRC_FILES := JNI_example.c #c 源文件 </span><br><span class="line">$ LOCAL_LDLIBS += -llog #依赖库 </span><br><span class="line">$ include $(BUILD EXECUTABLE) #将.c 构建为可执行程序，使用 shared_library 则会生成动态链接库， 使用 static_library 会生成静态链接库 </span><br></pre></td></tr></table></figure><br /> 准备 <span class="exturl" data-url="aHR0cDovL0FwcGxpY2F0aW9uLm1r">Application.mk</span> 文件，文件内代码如下所示：<br /><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$  APP_API := x86 armeabi-v7a</span><br></pre></td></tr></table></figure><br /> 在以上文件存储处打开 cmd，执行 ndk-build 指令生成 linux 下的可执行程序。</p><h1 id="相关函数"><a class="anchor" href="#相关函数">#</a> 相关函数</h1><p>jni 中的函数可以在 /java/include 下的 jni.h 文件中查询，以下只列举了一些可能使用到的函数。</p><h2 id="调用-java-层普通方法"><a class="anchor" href="#调用-java-层普通方法">#</a> 调用 java 层普通方法</h2><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ （*CallObjectMethod) (JNIEnv*, jobject, jmethodID, ...);</span><br></pre></td></tr></table></figure><br /> 前两个为默认参数，第三个参数由以下方法获取。</p><h2 id="获取-java-层实例方法的值"><a class="anchor" href="#获取-java-层实例方法的值">#</a> 获取 java 层实例方法的值</h2><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$  jmethodID (*GetMethodID) (JNIEnv*, jclass, const char*, const char*);</span><br></pre></td></tr></table></figure><br /> 其中，第一个 const char * 为 java 层方法名称，第二个 const char * 为 java 层方法的签名 (即方法返回类型)，而 jclass 由以下方法获取：<br /><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ jclass (*FindClass) (JNIEnv*, const char*)</span><br></pre></td></tr></table></figure><br /> 其中，const char * 为目标所在 class 的路径 (使用 \ 代替.)。</p><h2 id="获取-java-层实例字段的值"><a class="anchor" href="#获取-java-层实例字段的值">#</a> 获取 java 层实例字段的值</h2><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ jobject (*GetObjectField) (JNIEnv*, jobject , jfieldID);</span><br></pre></td></tr></table></figure><br /> 其中，jfieldID 由以下代码获取：<br /><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ jfieldID (*GetFieldID) (JNIenv*, jclass, const char*, const char*);</span><br></pre></td></tr></table></figure><br /> 第一个 const char * 为实例字段的名称，第二个 const char * 为实例字段签名 (即实例字段类型)。</p><h2 id="设置-java-层实例字段的值"><a class="anchor" href="#设置-java-层实例字段的值">#</a> 设置 java 层实例字段的值</h2><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ void (*SetObjectField) (JNIEnv*, jobject, jfieldID, jobject);</span><br></pre></td></tr></table></figure><br /> 第二个 jobject 为 java 层实例字段设置的值。</p><h1 id="静态注册"><a class="anchor" href="#静态注册">#</a> 静态注册</h1><h2 id="生成-jni-头文件"><a class="anchor" href="#生成-jni-头文件">#</a> 生成 jni 头文件</h2><p>在 class 代码中声明 native 方法，之后在 cmd 窗口中切换到源码目录处，执行以下代码生成 jni 头文件：<br /><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ javah -jni com.example.main.class</span><br></pre></td></tr></table></figure></p><h2 id="编写-c-代码"><a class="anchor" href="#编写-c-代码">#</a> 编写 c 代码</h2><p>在 c 文件中 include 之前生成的头文件，之后便能在 c 文件中具体实现在头文件中声明的函数。</p><h2 id="生成动态链接库"><a class="anchor" href="#生成动态链接库">#</a> 生成动态链接库</h2><p>将之前的两个 mk 文件同.c 与.h 文件放在同一文件夹下，使用 ndk-build 生成动态链接库文件。</p><h2 id="调用动态链接库"><a class="anchor" href="#调用动态链接库">#</a> 调用动态链接库</h2><p>在 java 代码中使用以下代码调用生成的动态链接库：<br /><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ System.loadLibrary (&quot;Module&quot;)</span><br></pre></td></tr></table></figure></p><h1 id="总结"><a class="anchor" href="#总结">#</a> 总结</h1><p>将以上个部分内容相结合，即可实现在 native 层调用 java 函数或获取 java 变量值。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;记录一些 jni 中的函数使用与静态注册相关知识。&lt;br /&gt;</summary>
    
    
    
    <category term="Android逆向知识" scheme="http://ericcd.com/categories/Android%E9%80%86%E5%90%91%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="jni" scheme="http://ericcd.com/tags/jni/"/>
    
    <category term="ndk" scheme="http://ericcd.com/tags/ndk/"/>
    
    <category term="静态注册" scheme="http://ericcd.com/tags/%E9%9D%99%E6%80%81%E6%B3%A8%E5%86%8C/"/>
    
  </entry>
  
  <entry>
    <title>Android 知识</title>
    <link href="http://ericcd.com/2022/02/27/Android-Knowledge/"/>
    <id>http://ericcd.com/2022/02/27/Android-Knowledge/</id>
    <published>2022-02-27T08:26:04.000Z</published>
    <updated>2022-07-17T08:28:57.806Z</updated>
    
    <content type="html"><![CDATA[<p>记录一些学习到的 Android 相关知识。<br /><span id="more"></span><br />1.application 中的 android:name 属性用来指定 app 启动时关联的 application，默认关联的为 android.app.Application。也可以将其设置为一个我们自己编辑的 class，该 class 将被 application 下的所有 activity 共享。<br />2.android.intent.action.MAIN 用于决定程序最先启动的 Activity，android.intent.category.LAUNCHER 用于决定程序是否显示在程序列表（桌面）里。没有 android.intent.action.MAIN，能够安装程序，但桌面不会显示启动器，程序也无法运行。<br />没有 android.intent.category.LAUNCHER，程序可以正常运行，但是桌面不会显示启动器。一个 apk 中有多个 activity 中存在 android.intent.action.MAIN 和 android.intent.category.LAUNCHER，桌面上会显示复数个应用图标，但是对应的为同一应用文件。<br />3. 在 Android 中使用 android.os.build 来获取设备相关信息，而 android.os.build 通过 SystemProperties.getString 来获取静态字段值，Systemproperties 是 android.os 中标记为 hide 的类，无法直接访问，但是可以通过反射的方式获取。该类使用 native 方法 native_get 来后去系统属性值，该方法的源代码在 android_os_SystemProperties.cpp 文件中。<br />4. 将 android.intent.category.LAUNCHER 更改为 -.INFO 或 -.FRAMEWORK_INSTRUMENTATION_TEST, 能够实现在桌面上隐藏程序同时不影响程序正常运行。并且因为没有了 android.inntent.category.LAUNCHER 作为特征，一些 apk 分析工具就无法定位 MainActivity。<br />5. 可以将 Androidmanifest 中的一些非必要标签的资源 ID 改为 0，从而屏蔽实现该标签的作用。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;记录一些学习到的 Android 相关知识。&lt;br /&gt;</summary>
    
    
    
    <category term="Android" scheme="http://ericcd.com/categories/Android/"/>
    
    
    <category term="Knowledge" scheme="http://ericcd.com/tags/Knowledge/"/>
    
  </entry>
  
  <entry>
    <title>Frida-2022.2.27-1</title>
    <link href="http://ericcd.com/2022/02/27/Frida-2022-2-27-1/"/>
    <id>http://ericcd.com/2022/02/27/Frida-2022-2-27-1/</id>
    <published>2022-02-27T03:18:05.000Z</published>
    <updated>2022-07-17T08:15:01.965Z</updated>
    
    <content type="html"><![CDATA[<p>利用 Frida 进行脱壳的过程记录。<br /><span id="more"></span></p><h1 id="工具准备"><a class="anchor" href="#工具准备">#</a> 工具准备</h1><p>通过以下命令安装 Frida 模块：<br /><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ pip install frida</span><br><span class="line">$ pip install frida-tools</span><br></pre></td></tr></table></figure><br /> 通过 github 下载 android 设备对应的 frida-server，通过以下命令将 frida-server 传输到 /data/local/tmp 目录下并设置可执行权限。<br /><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ adb push frida-server /data/local/tmp</span><br><span class="line">$ adb shell</span><br><span class="line">$ cd /data/local/tmp</span><br><span class="line">$ chmod 777 frida-server</span><br></pre></td></tr></table></figure><br /> 使用以下命令安装 frida-dexdump<br /><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pip install frida-dexdump</span><br></pre></td></tr></table></figure></p><h1 id="脱壳过程"><a class="anchor" href="#脱壳过程">#</a> 脱壳过程</h1><p>首先将 apk 安装到设备中。<br /><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ adb install apk</span><br></pre></td></tr></table></figure></p><p>进入 frida-server 的存放目录，运行 frida-server。<br /><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ adb shell</span><br><span class="line">$ cd /data/local/tmp</span><br><span class="line">$ ./frida-server</span><br></pre></td></tr></table></figure><br /> 另外打开一个 cmd，执行以下命令进行脱壳：<br /><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ frida -dexdump -U -f apk.packagename distPath</span><br></pre></td></tr></table></figure></p><p>apk.packagename 为需要脱壳的 apk 的包名，distPath 为用户指定的 dex 存放地址。<br />Frida 是一款很好用的工具，它的其它功能有待后续尝试。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;利用 Frida 进行脱壳的过程记录。&lt;br /&gt;</summary>
    
    
    
    <category term="Android逆向工具" scheme="http://ericcd.com/categories/Android%E9%80%86%E5%90%91%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="Frida" scheme="http://ericcd.com/tags/Frida/"/>
    
    <category term="apk脱壳" scheme="http://ericcd.com/tags/apk%E8%84%B1%E5%A3%B3/"/>
    
  </entry>
  
  <entry>
    <title>Android 逆向学习 - 2022.2.27-3</title>
    <link href="http://ericcd.com/2022/02/27/Android-reverce-2022.2.27-3/"/>
    <id>http://ericcd.com/2022/02/27/Android-reverce-2022.2.27-3/</id>
    <published>2022-02-27T03:07:59.000Z</published>
    <updated>2022-02-27T09:06:31.603Z</updated>
    
    <content type="html"><![CDATA[<p>JEB 使用记录。<br /><span id="more"></span><br />1.ctrl+b 设置断点 (只能在 smali 中设置)。<br />2. 快捷键 q 切换代码界面。<br />3.Debugger-&gt;start-&gt;attach。选择 Process 附加，之后程序开始运行。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;JEB 使用记录。&lt;br /&gt;</summary>
    
    
    
    <category term="Android逆向工具" scheme="http://ericcd.com/categories/Android%E9%80%86%E5%90%91%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="JEB" scheme="http://ericcd.com/tags/JEB/"/>
    
  </entry>
  
  <entry>
    <title>Android 逆向学习 - 2022.2.27-2</title>
    <link href="http://ericcd.com/2022/02/27/Android-reverce-2022.2.27-2/"/>
    <id>http://ericcd.com/2022/02/27/Android-reverce-2022.2.27-2/</id>
    <published>2022-02-27T02:34:09.000Z</published>
    <updated>2022-07-17T08:12:19.129Z</updated>
    
    <content type="html"><![CDATA[<p>ddms 工具使用记录。<br /><span id="more"></span></p><h1 id="打开-ddms"><a class="anchor" href="#打开-ddms">#</a> 打开 ddms</h1><p>在配置好 sdk 环境的前提下，通过命令行输入 ddms 直接打开。</p><h1 id="过滤器使用"><a class="anchor" href="#过滤器使用">#</a> 过滤器使用</h1><p>通 apk 报名设置过滤器。</p><h1 id="配合插桩调试"><a class="anchor" href="#配合插桩调试">#</a> 配合插桩调试</h1><ol><li>通过 Android Killer 在代码中插入日志输出代码。</li><li>通过 ddms 查看输出的日志信息。</li></ol><p>因为需要使用寄存器存放输出的日志字符串，所以需要确定声明的寄存器数量 (.locals) 是否足够。</p><h1 id="栈跟踪"><a class="anchor" href="#栈跟踪">#</a> 栈跟踪</h1><p>通过插桩找到目标，之后往上分析堆栈确定调用过程。</p><h1 id="方法刨析"><a class="anchor" href="#方法刨析">#</a> 方法刨析</h1><p>设置方法刨析，开始刨析后运行 app 中想要分析的功能，之后立即停止方法刨析。凭此获得方法调用表。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;ddms 工具使用记录。&lt;br /&gt;</summary>
    
    
    
    <category term="Android逆向工具" scheme="http://ericcd.com/categories/Android%E9%80%86%E5%90%91%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="ddms" scheme="http://ericcd.com/tags/ddms/"/>
    
  </entry>
  
  <entry>
    <title>Android 逆向学习 - 2022.2.27-1</title>
    <link href="http://ericcd.com/2022/02/27/android-reverce-2022.2.27-1/"/>
    <id>http://ericcd.com/2022/02/27/android-reverce-2022.2.27-1/</id>
    <published>2022-02-27T01:52:01.000Z</published>
    <updated>2022-02-27T08:01:17.155Z</updated>
    
    <content type="html"><![CDATA[<p>使用 Android Studio 进行动态调试。<br /><span id="more"></span><br />1.File-&gt;settings-&gt;plugins-&gt;install plugin from disk。通过以上步骤导入 smalidea。<br />2. 使用 Android Killer 打开目标 apk，右键注册机，进入文件路径，将 Project 文件通过 AS 的 import settings 导入。<br />3. 右键 smali 文件，选择 make directory as test sources root，赋予文件权限。<br />4. 进入 File-&gt;project structure，选择 sdk 版本。<br />5.Run-&gt;edit configurations，添加一个 Remote 调试器，设置端口号与 module。<br />6. 使用 adb shell ps 查看进程信息。<br />7.adb forward tcp: 调试器端口号 jdwp: 待调试进程 ID。</p><p>接下来就能开始进行动态调试。（Androidmanifest 中的 android:debuggable 需要设置为 true)</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;使用 Android Studio 进行动态调试。&lt;br /&gt;</summary>
    
    
    
    <category term="Android逆向工具" scheme="http://ericcd.com/categories/Android%E9%80%86%E5%90%91%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="Android Studio" scheme="http://ericcd.com/tags/Android-Studio/"/>
    
  </entry>
  
</feed>
